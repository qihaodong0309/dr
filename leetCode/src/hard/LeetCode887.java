package hard;

/**
 * @author qihaodong
 */
public class LeetCode887 {

    /*
    题目难度较大，采用（二分 + dp + 数学）
    如果用 K 表示鸡蛋数，N 表示楼层数，假设我们从第 x 层扔鸡蛋
    dp[k,n] = max(dp[k-1,x-1],dp[k,n-x]);
    前者表示鸡蛋碎了，鸡蛋数减一，临界楼层处于 0 ~ x-1 区间
    后者表示鸡蛋没碎，鸡蛋数不变，临界楼层处于 x ~ n 区间
    而 x 可以是任何值，因此需要遍历所有情况，总的方程式为
    dp[k,n] = min(max(dp[k-1,x-1],dp[k,n-x])),其中 min 遍历所有 k 的情况
    这里遍历所有情况太过复杂，因此可以考虑采用数学方法
    随着 x 的增加，dp[k-1,x-1] 越来越大，dp[k,n-x]越来越小
    要使两者的最大值较小，即dp[k-1][x-1] 和 dp[k,n-x]最接近的时候
     */

    public int superEggDrop(int K, int N) {
        int[] dp = new int[N + 1];
        // 这里表示只有一个鸡蛋时，每次只能从最底层扔，从哪层破裂答案就是哪一层
        // 所以当有 N 层时，最坏情况即临界破裂层就在第 N 层，此时需要扔 N 次
        for (int i = 0; i <= N; ++i) {
            dp[i] = i;
        }
        // 遍历鸡蛋的数量
        for (int k = 2; k <= K; ++k) {
            int[] dp2 = new int[N + 1];
            // 模拟在第 x 层扔鸡蛋
            int x = 1;
            // 遍历楼层的数量
            // 随着楼层 n 的增加，后一个函数会更大，相同横坐标，第二个函数的值会更大，因此最小值 x 只会向右移
            for (int n = 1; n <= N; ++n) {
                // 如果从 x 层扔计算出的结果大于从 x + 1 层计算出的结果
                // 鸡蛋碎的函数是随 x 增大而增大的，鸡蛋不碎的结果是随 X 增大而减小的
                // 因此最优解肯定是两者函数大小差异最小时，一开始随着 X 的增大，总结果肯定是减少的
                // 当出现后一个比前一个增大时，说明当前楼层 X 计算出的解最优
                // 可以这样理解，总值会呈现先减小后增加的局面，通过这个 while 循环可以找到最小值
                while (x < n && Math.max(dp[x - 1], dp2[n - x]) > Math.max(dp[x], dp2[n - x - 1])) {
                    x++;
                }
                // dp[x - 1] 表示 X 层鸡蛋碎了，dp 表示的鸡蛋数减一的函数，总结果在 x - 1 中
                // dp2[n - x] 表示 X 层鸡蛋没碎，dp2 表示鸡蛋数量不变，此时最优解即 dp[n - x]
                dp2[n] = 1 + Math.max(dp[x - 1], dp2[n - x]);
            }
            dp = dp2;
        }
        return dp[N];
    }

}
